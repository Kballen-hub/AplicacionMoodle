{"version":3,"file":"datetime.min.js","sources":["../../../src/datafilter/filtertypes/datetime.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Base filter for a date/time selector\n *\n * @module     core/datafilter/filtertypes/datetime\n * @author     Mark Johnson <mark.johnson@catalyst-eu.net>\n * @copyright  2024 Catalyst IT Europe Ltd\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Filter from 'core/datafilter/filtertype';\nimport Selectors from 'core/datafilter/selectors';\nimport Templates from 'core/templates';\nimport Notification from 'core/notification';\nimport {get_strings as getStrings} from 'core/str';\n\nconst MODES = {\n    before: 'before',\n    after: 'after',\n    between: 'between',\n};\n\nexport default class extends Filter {\n\n    SELECTORS = {\n        afterwrapper: `.${this.filterType}-afterwrapper`,\n        beforewrapper: `.${this.filterType}-beforewrapper`,\n        betweenwrapper: `.${this.filterType}-betweenwrapper`,\n        mode: `[data-filterfield=${this.filterType}-mode]`,\n    };\n\n    mode = null;\n\n    constructor(filterType, rootNode, initialValues, filterOptions = {mode: MODES.before}) {\n        super(filterType, rootNode, initialValues);\n        this.addModeSelector(filterOptions.mode);\n    }\n\n    /**\n     * Get the context object to be sent through to the mustache template.\n     * This can be overridden by any filters which inherit from datetime to add/exclude data.\n     *\n     * @param {array} initialValues\n     * @returns {Promise<{filtertype: *, afterlabel: *, beforelabel: *, required, aftervalue: *, beforevalue: *}>}\n     */\n    async getContext(initialValues) {\n        const sourceDataNode = this.getSourceDataForFilter();\n        const defaultBefore = sourceDataNode.getElementsByTagName('option')[0].value;\n        const defaultAfter = sourceDataNode.getElementsByTagName('option')[1].value;\n        const title = sourceDataNode.getAttribute('data-field-title');\n        const labels = await getStrings([\n            {\n                key: 'datetimefilterafter',\n                component: 'core',\n                param: {title},\n            },\n            {\n                key: 'datetimefilterbefore',\n                component: 'core',\n                param: {title},\n            },\n        ]);\n        return {\n            filtertype: this.filterType,\n            afterlabel: labels[0],\n            beforelabel: labels[1],\n            required: sourceDataNode.dataset.required,\n            aftervalue: initialValues[0] ?? defaultAfter,\n            beforevalue: initialValues[1] ?? defaultBefore,\n        };\n    }\n\n    async addValueSelector(initialValues = []) {\n        // We specify a specific filterset in case there are multiple filtering condition - avoiding glitches.\n        const specificFilterSet = this.rootNode.querySelector(Selectors.filter.byName(this.filterType));\n        const context = await this.getContext(initialValues);\n        const datetimeUi = await Templates.renderForPromise('core/datafilter/filtertypes/datetime_selector', context);\n        return Templates.replaceNodeContents(\n            specificFilterSet.querySelector(Selectors.filter.regions.values),\n            datetimeUi.html,\n            datetimeUi.js\n        );\n    }\n    async addModeSelector(mode) {\n        const modeStrings = await getStrings([\n            {key: 'selectdates'},\n            {key: 'filterdatebefore', component: 'reportbuilder'},\n            {key: 'filterdateafter', component: 'reportbuilder'},\n            {key: 'between'}\n        ]);\n        const context = {\n            label: modeStrings[0],\n            filtertype: this.filterType,\n            modeoptions: [\n                {\n                    value: MODES.before,\n                    label: modeStrings[1],\n                    selected: mode === MODES.before ? 'selected' : '',\n                },\n                {\n                    value: MODES.after,\n                    label: modeStrings[2],\n                    selected: mode === MODES.after ? 'selected' : '',\n                },\n                {\n                    value: MODES.between,\n                    label: modeStrings[3],\n                    selected: mode === MODES.between ? 'selected' : '',\n                },\n            ],\n        };\n        const modeUi = await Templates.renderForPromise('core/datafilter/filtertypes/datetime_mode', context);\n        const filterValueNode = this.getFilterValueNode();\n        filterValueNode.insertAdjacentHTML('beforebegin', modeUi.html);\n        const modeSelect = this.filterRoot.querySelector(this.SELECTORS.mode);\n        modeSelect.addEventListener('change', this.updateFieldVisibility.bind(this));\n        modeSelect.dispatchEvent(new Event('change')); // Update field visibility based on initial mode.\n    }\n\n    updateFieldVisibility(event) {\n        const filterValueNode = this.getFilterValueNode();\n        const afterWrapper = filterValueNode.querySelector(this.SELECTORS.afterwrapper);\n        const beforeWrapper = filterValueNode.querySelector(this.SELECTORS.beforewrapper);\n        const betweenWrapper = filterValueNode.querySelector(this.SELECTORS.betweenwrapper);\n        const value = event.target.value;\n        if (value === MODES.between) {\n            betweenWrapper.classList.remove('d-none');\n        } else {\n            betweenWrapper.classList.add('d-none');\n        }\n        if (value === MODES.after || value === MODES.between) {\n            afterWrapper.classList.remove('d-none');\n        } else {\n            afterWrapper.classList.add('d-none');\n        }\n        if (value === MODES.before || value === MODES.between) {\n            beforeWrapper.classList.remove('d-none');\n        } else {\n            beforeWrapper.classList.add('d-none');\n        }\n    }\n\n    get values() {\n        return [\n            this.filterRoot.querySelector(`[data-filterfield=\"${this.name}1\"]`).value,\n            this.filterRoot.querySelector(`[data-filterfield=\"${this.name}2\"]`).value,\n        ];\n    }\n\n    get filterOptions() {\n        return [\n            {name: 'mode', value: this.filterRoot.querySelector(this.SELECTORS.mode).value}\n        ];\n    }\n\n    get filterValue() {\n        return {\n            name: this.name,\n            jointype: this.jointype,\n            values: this.values,\n            filteroptions: this.filterOptions,\n        };\n    }\n\n    validate() {\n        const mode = document.querySelector(this.SELECTORS.mode).value;\n        const before = document.querySelector(this.SELECTORS.beforewrapper + ' input');\n        const after = document.querySelector(this.SELECTORS.afterwrapper + ' input');\n        after.setCustomValidity('');\n        if (mode === MODES.between) {\n            if (after.value >= before.value) {\n                getStrings([\n                    {\n                        key: 'invaliddatetimebetween',\n                        component: 'error',\n                        param: {\n                            before: before.value,\n                            after: after.value,\n                        },\n                    },\n                ]).then((strings) => {\n                    after.setCustomValidity(strings[0]);\n                    after.reportValidity();\n                    return strings;\n                }).catch(Notification.exception);\n                return false;\n            }\n        }\n\n        return true;\n    }\n}"],"names":["MODES","Filter","SELECTORS","afterwrapper","this","filterType","beforewrapper","betweenwrapper","mode","constructor","rootNode","initialValues","filterOptions","addModeSelector","sourceDataNode","getSourceDataForFilter","defaultBefore","getElementsByTagName","value","defaultAfter","title","getAttribute","labels","key","component","param","filtertype","afterlabel","beforelabel","required","dataset","aftervalue","beforevalue","specificFilterSet","querySelector","Selectors","filter","byName","context","getContext","datetimeUi","Templates","renderForPromise","replaceNodeContents","regions","values","html","js","modeStrings","label","modeoptions","selected","modeUi","getFilterValueNode","insertAdjacentHTML","modeSelect","filterRoot","addEventListener","updateFieldVisibility","bind","dispatchEvent","Event","event","filterValueNode","afterWrapper","beforeWrapper","betweenWrapper","target","classList","remove","add","name","filterValue","jointype","filteroptions","validate","document","before","after","setCustomValidity","then","strings","reportValidity","catch","Notification","exception"],"mappings":"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"}